section .text
	global _ft_bzero

_ft_bzero:
	push rdi
	mov rbp, rsp
	Bouboule:
		mov byte [rdi], 0
		inc rdi ; go to next octet
		dec rsi ; dec size
		cmp rsi, 0 ; tant que n est different de 0 on boucle
		jne Bouboule
	End:
		leave
		ret
global _ft_isalnum
extern _ft_isdigit
extern _ft_isalpha

_ft_isalnum:
	call _ft_isdigit
	cmp rax, 1
	je GoodAlnum

	call _ft_isalpha
	cmp rax, 1
	je GoodAlnum

	ErrorAlnum:
		mov rax, 0
		jmp EndAlnum
	GoodAlnum:
		mov rax, 1
	EndAlnum:
		ret
global _ft_isminus
global _ft_ismajus
global _ft_isalpha

_ft_isminus:
        cmp rdi, 'a' ; '0'
        jl ErrorMin ; rdi < 'a'
        cmp rdi, 'z' ; 'z'
        jg ErrorMin ; '9' < rdi
        GoodMin:
                mov rax, 1
                jmp EndMin
        ErrorMin:
                mov rax, 0
        EndMin:
                ret

_ft_ismajus:
        cmp rdi, 'A' ; 'A'
        jl ErrorMaj ; rdi < 'A'
        cmp rdi, 'Z' ; 'Z'
        jg ErrorMaj ; 'Z' < rdi
        GoodMaj:
                mov rax, 1
                jmp EndMaj
        ErrorMaj:
                mov rax, 0
        EndMaj:
                ret

_ft_isalpha:
        call _ft_isminus
        cmp rax, 1
        je Good

        call _ft_ismajus
        cmp rax, 1
        je Good

        Error:
                mov rax, 0
                jmp End
        Good:
                mov rax, 1
        End:
                ret
global _ft_isascii

_ft_isascii:
        cmp rdi, 0 ; '0'
        jl ErrorAscii ; rdi < '0'
        cmp rdi, 127 ; '9'
        jg ErrorAscii ; '9' < rdi
        GoodAscii:
                mov rax, 1
                jmp EndAscii
        ErrorAscii:
                mov rax, 0
        EndAscii:
                ret
global _ft_isdigit

; use rdi
_ft_isdigit:
	cmp rdi, '0' ; '0'
	jl Error ; rdi < '0'
	cmp rdi, '9' ; '9'
	jg Error ; '9' < rdi
	Good:
		mov rax, 1
		jmp End
	Error:
		mov rax, 0
	End:
		ret
global _ft_isprint

ft_isprint:
	cmp rdi, 31
	jle Error
	cmp rdi, 127
	jge Error
	Good:
		mov rax, 1
		jmp End
	Error:
		mov rax, 0
	End:
		ret
;void * memcpy(void *restrict dst, const void *restrict src, size_t n);

global _ft_memcpy

_ft_memcpy:
	push rbp
	mov rbp, rsp


.end:
	leave
	ret
global _ft_memset

; void *ft_memset(void *b, int c, size_t len);
; rax		  rdi,     rsi     rdx
; trouve4r le moyen de copier c dans b avec une repetition de len
; repetition ok
; copier ? stos*

_ft_memset:
	push rbp
	mov rbp, rsp
	mov r11, rdi

; copier x fois le caractere rsi
	mov rcx, rdx; initialisatyion du compteur avec len for rep isntruction
	mov rax, rsi; caractere a copier
	cld ; flag df cleared at 0, then we incremente :)
	; stosb :  store al at 
	; si le flag df est a 0 alors ca incremente, si 1 a alors decremente
	; df == 0
	rep stosb

.end:
	mov rax, r11
	leave
	ret
%define MACH_SYSCALL(nb)	0x2000000 | nb
%define STDOUT			1
%define WRITE			4

global _ft_puts
extern _ft_strlen

_ft_puts:
	mov rsi, rdi
	call _ft_strlen ;store len in rax
	mov rdi, STDOUT ; output (fd)
	;lea rsi, [rel rax]
	mov rdx, rax ; size
	mov rax, MACH_SYSCALL(WRITE) ; syscall
	syscall
	mov rax, rdx
	ret
global _ft_strcat
extern _ft_strcpy
extern _ft_strlen

_ft_strcat:
	push rbp
	mov rbp, rsp
	mov rax, rdi
.iter:
	mov cl, [rdi]
	cmp cl, 0
	je .copy
	inc rdi
	jmp .iter
.copy:
	call _ft_strcpy
	leave
	ret
global _ft_strcpy

; rdi, rsi
_ft_strcpy2:
	push rbp
	mov rbp, rsp
	mov r11, rdi
.Cp:
	mov cl, [rsi]; // ici on copie caractere par caractere
	mov [rdi], cl;
	cmp  cl, 0
	je .End
	inc rsi
	inc rdi
	jmp .Cp
	.End:
		mov rax, r11
		movsb
		leave
		ret

; rdi, rsi
_ft_strcpy:
        push rbp
        mov rbp, rsp
	mov rax, rdi ; save return addr
.Cpp:
        movsd ; copi actual bit in rdi --> rsp, and incr this register
	cmp byte[rsi], 0
        jne .Cpp ; tant que actual_char != 0 --> loop

	movsd ; copy last bit
	leave
	ret
global _ft_strlen

_ft_strlen:

	cmp rdi, 0 ;
	je EndOfYourWorld; string == NULL

	mov al, 0 ; value research, we want end of character
	mov rcx, -1; initialisation du compteur, 0 == condition d arret de scasb
	cld; clars df flag, then indicate we want auto incremenete edi register to runing around string
	repne scasb ; incremente rdi for dtring and decrease rcx | loop
	mov rax, rcx ; recuperation de la valeur de l accumalateur
	neg rax ; l accumulateur rcx, decremente, nous devons donc passer la valeur en positif
	sub rax, 2 ; get real length
	ret

	EndOfYourWorld:
		mov rax, 0
		ret
global _ft_tolower
extern _ft_ismajus

_ft_tolower:
	call _ft_ismajus
	cmp rax, 0
	je EndTolower

	GoodTolower:
		sub rdi, 'A'
		add rdi, 'a'
	EndTolower:
		mov rax, rdi
		ret
global _ft_toupper
extern _ft_isminus

_ft_toupper:
	call _ft_isminus
	cmp rax, 0
	je EndToupper

	GoodToupper:
		sub rdi, 'a'
		add rdi, 'A'
	EndToupper:
		mov rax, rdi
		ret
	.section	__TEXT,__text,regular,pure_instructions
	.macosx_version_min 10, 12
	.globl	_ft_bzero
	.p2align	4, 0x90
_ft_bzero:                              ## @ft_bzero
	.cfi_startproc
## BB#0:
	pushq	%rbp
Lcfi0:
	.cfi_def_cfa_offset 16
Lcfi1:
	.cfi_offset %rbp, -16
	movq	%rsp, %rbp
Lcfi2:
	.cfi_def_cfa_register %rbp
	movq	%rdi, -8(%rbp)
	movq	%rsi, -16(%rbp)
	movq	$0, -24(%rbp)
	movq	-8(%rbp), %rsi
	movq	%rsi, -32(%rbp)
LBB0_1:                                 ## =>This Inner Loop Header: Depth=1
	movq	-24(%rbp), %rax
	cmpq	-16(%rbp), %rax
	jae	LBB0_3
## BB#2:                                ##   in Loop: Header=BB0_1 Depth=1
	movq	-32(%rbp), %rax
	movq	-24(%rbp), %rcx
	movb	$0, (%rax,%rcx)
	movq	-24(%rbp), %rax
	addq	$1, %rax
	movq	%rax, -24(%rbp)
	jmp	LBB0_1
LBB0_3:
	popq	%rbp
	retq
	.cfi_endproc


.subsections_via_symbols
